// Import the existing file content up to the handleUpdateAllAssemblies function
$(head -n 800 /user/z37/geant4_projects/geant4-geometry-editor/src/components/Viewer3D.jsx)

  // Function to update all similar assemblies
  const handleUpdateAllAssemblies = (volumeIndex) => {
    handleCloseContextMenu();
    
    // Get the selected volume
    const selectedVolume = geometries.volumes[volumeIndex];
    
    // Only proceed if the selected volume is an assembly
    if (selectedVolume.type !== 'assembly') {
      alert('Only assemblies can be updated. Please select an assembly.');
      return;
    }
    
    // Count of updated assemblies
    let updatedCount = 0;
    
    // First, find all components in the source assembly
    const sourceComponents = [];
    const sourceAssemblyName = selectedVolume.name;
    
    // Find all components that belong to the source assembly
    for (let i = 0; i < geometries.volumes.length; i++) {
      const volume = geometries.volumes[i];
      if (volume.mother_volume === sourceAssemblyName) {
        sourceComponents.push({
          index: i,
          volume: volume,
          _componentId: volume._componentId
        });
      }
    }
    
    console.log(`Found ${sourceComponents.length} components in source assembly ${sourceAssemblyName}:`, sourceComponents);
    
    // Update all assemblies except the selected one
    for (let i = 0; i < geometries.volumes.length; i++) {
      const volume = geometries.volumes[i];
      
      // Skip the source assembly itself
      if (i === volumeIndex) continue;
      
      // Only update assemblies
      if (volume.type !== 'assembly') continue;
      
      const targetAssemblyName = volume.name;
      
      // Create a new object with properties from the selected assembly
      // but preserve position, rotation, and name of the target assembly
      const updatedAssembly = {
        ...selectedVolume,
        // Preserve these properties
        position: { ...volume.position },
        rotation: { ...volume.rotation },
        name: targetAssemblyName, // CRITICAL: Preserve the assembly name
        mother_volume: volume.mother_volume,
        // If there's a displayName or g4name, preserve those too
        ...(volume.displayName && { displayName: volume.displayName }),
        ...(volume.g4name && { g4name: volume.g4name })
      };
      
      // If the assembly has an instance ID, preserve it
      if (volume._instanceId) {
        updatedAssembly._instanceId = volume._instanceId;
      }
      
      // Debug logs
      console.log(`Updating assembly at index ${i}:`, {
        sourceAssembly: selectedVolume,
        targetAssembly: volume,
        updatedAssembly: updatedAssembly
      });
      
      // Update this specific assembly
      // Use the volume ID format: 'volume-index'
      onUpdateGeometry(`volume-${i}`, updatedAssembly, true, false);
      
      // Now update all components of this assembly
      // First, find all components that belong to this target assembly
      const targetComponents = [];
      for (let j = 0; j < geometries.volumes.length; j++) {
        const component = geometries.volumes[j];
        if (component.mother_volume === targetAssemblyName) {
          targetComponents.push({
            index: j,
            volume: component,
            _componentId: component._componentId
          });
        }
      }
      
      console.log(`Found ${targetComponents.length} components in target assembly ${targetAssemblyName}:`, targetComponents);
      
      // For each source component, find matching target component by _componentId
      // and update it with the source component's properties
      for (const sourceComponent of sourceComponents) {
        // Find matching target component by _componentId
        const matchingTargetComponent = targetComponents.find(tc => 
          tc._componentId && sourceComponent._componentId && tc._componentId === sourceComponent._componentId
        );
        
        if (matchingTargetComponent) {
          // Create updated component with properties from source but preserve critical identifiers
          const updatedComponent = {
            ...sourceComponent.volume,
            name: matchingTargetComponent.volume.name, // CRITICAL: Preserve internal name
            mother_volume: targetAssemblyName, // Preserve parent relationship
            _componentId: matchingTargetComponent.volume._componentId // Preserve component ID
          };
          
          // If there's a displayName or g4name, preserve those too
          if (matchingTargetComponent.volume.displayName) {
            updatedComponent.displayName = matchingTargetComponent.volume.displayName;
          }
          if (matchingTargetComponent.volume.g4name) {
            updatedComponent.g4name = matchingTargetComponent.volume.g4name;
          }
          
          console.log(`Updating component at index ${matchingTargetComponent.index}:`, {
            sourceComponent: sourceComponent.volume,
            targetComponent: matchingTargetComponent.volume,
            updatedComponent: updatedComponent
          });
          
          // Update this specific component
          onUpdateGeometry(`volume-${matchingTargetComponent.index}`, updatedComponent, true, false);
        } else {
          console.log(`No matching component found for source component with ID ${sourceComponent._componentId}`);
        }
      }
      
      updatedCount++;
    }
    
    // Show success message
    if (updatedCount > 0) {
      alert(`Updated ${updatedCount} assemblies successfully.`);
    } else {
      alert('No other assemblies found to update.');
    }
  };
  
  // Function to update selected assemblies
  const handleUpdateSelectedAssemblies = (volumeIndex) => {
    handleCloseContextMenu();
    
    // Get the selected volume
    const selectedVolume = geometries.volumes[volumeIndex];
    
    // Only proceed if the selected volume is an assembly
    if (selectedVolume.type !== 'assembly') {
      alert('Only assemblies can be updated. Please select an assembly.');
      return;
    }
    
    // Find all assemblies in the scene
    const allAssemblies = geometries.volumes
      .map((volume, index) => ({ volume, index }))
      .filter(item => item.volume.type === 'assembly' && item.index !== volumeIndex);
    
    if (allAssemblies.length === 0) {
      alert('No other assemblies found to update.');
      return;
    }
    
    // Create a simple selection dialog
    const assemblyOptions = allAssemblies.map(item => 
      `${item.index}: ${item.volume.name}`
    ).join('\n');
    
    const userInput = prompt(
      `Select assemblies to update (comma-separated indices):\n${assemblyOptions}`,
      ''
    );
    
    if (!userInput) return; // User cancelled
    
    // Parse the selected indices
    const selectedIndices = userInput.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
    
    if (selectedIndices.length === 0) {
      alert('No valid indices selected.');
      return;
    }
    
    // First, find all components in the source assembly
    const sourceComponents = [];
    const sourceAssemblyName = selectedVolume.name;
    
    // Find all components that belong to the source assembly
    for (let i = 0; i < geometries.volumes.length; i++) {
      const volume = geometries.volumes[i];
      if (volume.mother_volume === sourceAssemblyName) {
        sourceComponents.push({
          index: i,
          volume: volume,
          _componentId: volume._componentId
        });
      }
    }
    
    console.log(`Found ${sourceComponents.length} components in source assembly ${sourceAssemblyName}:`, sourceComponents);
    
    // Count of successfully updated assemblies
    let updatedCount = 0;
    
    // Update the selected assemblies
    for (const index of selectedIndices) {
      // Skip invalid indices
      if (index < 0 || index >= geometries.volumes.length) continue;
      
      const volume = geometries.volumes[index];
      
      // Skip non-assemblies
      if (volume.type !== 'assembly') continue;
      
      const targetAssemblyName = volume.name;
      
      // Create a new object with properties from the selected assembly
      // but preserve position, rotation, and name of the target assembly
      const updatedAssembly = {
        ...selectedVolume,
        // Preserve these properties
        position: { ...volume.position },
        rotation: { ...volume.rotation },
        name: targetAssemblyName, // CRITICAL: Preserve the assembly name
        mother_volume: volume.mother_volume,
        // If there's a displayName or g4name, preserve those too
        ...(volume.displayName && { displayName: volume.displayName }),
        ...(volume.g4name && { g4name: volume.g4name })
      };
      
      // If the assembly has an instance ID, preserve it
      if (volume._instanceId) {
        updatedAssembly._instanceId = volume._instanceId;
      }
      
      // Update this specific assembly
      // Use the volume ID format: 'volume-index'
      onUpdateGeometry(`volume-${index}`, updatedAssembly, true, false);
      
      // Now update all components of this assembly
      // First, find all components that belong to this target assembly
      const targetComponents = [];
      for (let j = 0; j < geometries.volumes.length; j++) {
        const component = geometries.volumes[j];
        if (component.mother_volume === targetAssemblyName) {
          targetComponents.push({
            index: j,
            volume: component,
            _componentId: component._componentId
          });
        }
      }
      
      console.log(`Found ${targetComponents.length} components in target assembly ${targetAssemblyName}:`, targetComponents);
      
      // For each source component, find matching target component by _componentId
      // and update it with the source component's properties
      for (const sourceComponent of sourceComponents) {
        // Find matching target component by _componentId
        const matchingTargetComponent = targetComponents.find(tc => 
          tc._componentId && sourceComponent._componentId && tc._componentId === sourceComponent._componentId
        );
        
        if (matchingTargetComponent) {
          // Create updated component with properties from source but preserve critical identifiers
          const updatedComponent = {
            ...sourceComponent.volume,
            name: matchingTargetComponent.volume.name, // CRITICAL: Preserve internal name
            mother_volume: targetAssemblyName, // Preserve parent relationship
            _componentId: matchingTargetComponent.volume._componentId // Preserve component ID
          };
          
          // If there's a displayName or g4name, preserve those too
          if (matchingTargetComponent.volume.displayName) {
            updatedComponent.displayName = matchingTargetComponent.volume.displayName;
          }
          if (matchingTargetComponent.volume.g4name) {
            updatedComponent.g4name = matchingTargetComponent.volume.g4name;
          }
          
          console.log(`Updating component at index ${matchingTargetComponent.index}:`, {
            sourceComponent: sourceComponent.volume,
            targetComponent: matchingTargetComponent.volume,
            updatedComponent: updatedComponent
          });
          
          // Update this specific component
          onUpdateGeometry(`volume-${matchingTargetComponent.index}`, updatedComponent, true, false);
        } else {
          console.log(`No matching component found for source component with ID ${sourceComponent._componentId}`);
        }
      }
      
      updatedCount++;
    }
    
    // Show success message
    if (updatedCount > 0) {
      alert(`Updated ${updatedCount} assemblies successfully.`);
    } else {
      alert('No assemblies were updated.');
    }
  };

$(tail -n +1200 /user/z37/geant4_projects/geant4-geometry-editor/src/components/Viewer3D.jsx)
